---
title: "SQLDF Package Review"
author: "Bill Cull, John Hope, and Jay Ralyea"
date: "4/5/2021"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(sqldf)
library(tidyverse)
library(DT)
```

# Overview


### Usage

The only function included in the sqldf package is sqldf(). Although the function is optimized for convenience, in some cases the sqldf function “can be faster than the corresponding pure R calculation.” The function takes R dataframe(s) in place of standard SQL table name(s) and automatically creates an appropriate database. sqldf() executes the specified SQL commands upon said database and returns an R dataframe. The database sqldf() created is deleted making the entire process “transparent” to the user. 

While there is only one function included in the sqldf package, there are many SQL keywords and functions available to the user through the package.

- SELECT: the primary function sqldf refers to. Specifies the columns in the database that the user wants to query
- FROM: specifies which table to select or delete data from
- WHERE: filters results to include only records that satisfy the given condition
- DELETE: deletes rows from a table
- DROP: deletes a column, constraint, database, index, table, or view
- GROUP BY: groups rows that have the same values into summary rows, frequently used with aggregate functions, such as COUNT(), MAX(), MIN(), SUM(), and AVG().
- ORDER BY: used to sort the result-set in ascending or descending order, ascending is default so use the DESC keyword to sort in descending order
- CASE: similar to a series of if, else if, and else statements in R. Case statements go through a set of conditions and execute the relevant code once a condition is met. 
  + WHEN: part of a CASE statement, the explicit condition to be met
  + THEN: follows a WHEN statement, the code to execute if the condition is met
  + ELSE: what to do if no condition is met, if there is no ELSE statement and no condition is met, the series will return NULL
  + END: signifies the end of a CASE statement
- JOIN: there are many different methods to join SQL tables together, here are two common examples (note: sqldf does not support right join, the equivalent is to swap the table order and use LEFT JOIN)
  + INNER JOIN: selects records that have matches in both tables and merges specified together, must specify which column to merge on in each table
  + LEFT JOIN: The result of LEFT JOIN shall be the same as the result of INNER JOIN + we’ll have rows, from the “left” table, without a pair in the “right” table



### Package Dependencies



# Examples of Usage: Exploring the NBA
In order to best demonstrate the functionality of sqldf and SQL in general, below are a few operations querying and manipulating data from the recent NBA clustering lab.

```{r UTF-8Compatible, results='hide'}
# Import the relevant data
stats <- read_csv("nba2020-21.csv")
salaries <- read_csv("nba_salaries_21.csv")

# Function to convert each name into UTF-8 compatible letters
utf_compatible <- function(name){
  Encoding(name) <- "UTF-8"
  iconv(name, "UTF-8", "UTF-8",sub='') ## replace any non UTF-8 by ''
}

stats$Player <- sapply(stats$Player, function(x) utf_compatible(x))
salaries$Player <- sapply(salaries$Player, function(x) utf_compatible(x))

# Reference: https://stackoverflow.com/questions/17291287/how-to-identify-
# delete-non-utf-8-characters-in-r
```


### Players who start all their games
```{r Starters}
# FIND ALL PLAYERS WHO HAVE STARTED EVERY GAME THEY HAVE PLAYED IN.

# First we want to SELECT all rows. We do this with the SELECT command
# followed by an "*". FROM designates which database to reference, in this
# case the "stats" tibble. Finally, where checks that the games played
# column, G, is equal to the games started column, GS.
starters <- sqldf("SELECT * FROM stats WHERE G == GS")
datatable(starters[, 1:6])
```





# Similar Pacakgees

With the scope of R packagses that are in existence, there must be some that are similar to ours. After some research, we were able to find some packages that showed at least some resemblance to sqldf. The first is [Reticulate](https://cran.r-project.org/web/packages/reticulate/reticulate.pdf). Reticulate provides a set of tools that allow for calling Python from R in Rmarkdown. It allows for sourcing Python scripts, Python Modules, and translation between R and Python Objects. This package would be particularly useful for teams who are collaborating within R but do not all use R. This is similar to sqldf in that it allows for the convenient implementation of a non-native language within the R environment. In the same way that sqldf allows for R users to implement SQL, Reticulate allows R users to impleement Python code. However, Retticulate differs itself from sqldf, as Reticulate can allow for an interactive Python console within R. Objects you create within Python are available to your R session, which is not necessarily guaranteed with the use of the sqldf package alone. Also, when the Reticulate package is accessed, output within R can be presented in python format, whereas the sqldf package only allows a user to implement SQL formatted commands for output that is still styled in the standard RStudio format.

A second package we found to be similar is [Rcpp](https://cran.r-project.org/web/packages/Rcpp/Rcpp.pdf). provides efficient integration of C++ and R by providing its own API over R’s C API. This can allow for many benefits for the C++ programer using R, such as the more efficient use of recursive functions and the use of advanced algorithms that R cannot provide. Just like as in sqldf and in Reticulate, Rcpp allows for the convenient implementation of a non-native language within the R environment. Rcpp utilizes C++ code in the same manner that sqldf utilizes SQL code. However, we can differentiate the two packages, as Rccp will compile C++ code and construct R functions that connects to the compiled C++ function in question, rather than literally typing SQL commands into the R environment as sqldf does. In addition, Rcpp does not require the use of assignment to create functions.


# Reflection

Overall, sqldf is a very convienient and effective package that can be used in a lot of ways. Using the sqldf() function, we can tackle both data preperation and data analysis, making this package very versatile. However, all things must have benefits and drawbacks associated with them. After our own experience with the package, as well as further research ino the community of sqldf users, we compiled lists of pros and cons associated with sqldf. The pros in this situation are plentiful, as the package is quite convinient and easy to use. First, sqldf() can manipulate data sets at times be even faster than the corresponding pure R calculation. The process in running sqldf() is that it creates a temporary database to store and manipulate the data frame being studied, then returns the new data frame and removes that temporary database. In addition, it has been suggested that aggregations over highly granular columns using sqldf is faster than any other alternative tried. From this, we see that the package function is highly efficient. Another pro for using sqldf is that it can be used as a bridge between SQL and R. Those who do not know SQL, but know R, can use this package to learn the foundations of SQL statements. Furthermore, those who don't know R, but know SQL, can use their SQL information and pair it with R commands and functions.

That being said, the package is not perfect. There are problems that some users experience, as well as some odd features. First, the sqldf package uses the gsubfn package for parsing and the gsubfn package optionally uses the tcltk R package which in turn uses string processing language, tcl, internally. A lot of times, this can cause problems for those who aren’t using recent versions of R, so all that has to be done is make sure your R is updated. A second complaint is that SQL is case insensitive. R on the other hand, is case sensitive, so the difference in sensitivity can be a nuissance at times. But, using the functions within this package also make R coding case insensitive. Therefore, one must always be cognisant of this to avoid mistakes and errors running code under this package. Lastly, although data frames referenced in the SQL statement(s) passed to sqldf are automatically imported to SQLite, sqldf does not automatically export anything for safety reasons. Users who are constantly updating tables and datasets have expressed this as a point of complaint, as there is a specific way this must be done under this package.
